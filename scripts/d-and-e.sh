#!/usr/bin/env bash
# (Mostly) Generated by Microsoft Copilot with a bit of coaxing
# (and quite a bit of annoyance)

set -ue -o pipefail

mkdir -p "${SOURCE_ROOT}" && cd "${SOURCE_ROOT}"

export BASE_URL="https://ftpmirror.gnu.org/"
# --- Files to fetch (relative to mirror root) ---
FILES=(
    "binutils/binutils-2.45.tar.bz2"
    "gcc/gcc-15.2.0/gcc-15.2.0.tar.gz"
    "mpfr/mpfr-4.2.2.tar.bz2"
    "gmp/gmp-6.3.0.tar.bz2"
    "mpc/mpc-1.3.1.tar.gz"
    "glibc/glibc-2.42.tar.bz2"
)

# --- Check if all files and signatures exist locally ---
needed_files=()
filenames=()
file_count=0
all_present=true
for f in "${FILES[@]}"; do
    filenames+=("$(basename "$f")")
    if [[ ! -f "${filenames[file_count]}" || ! -f "${filenames[file_count]}.sig" ]]; then
        all_present=false
        needed_files+=("${f}")
    fi
    ((file_count++))
done

# --- Conditional network connectivity test ---
if [[ "$all_present" == false ]]; then
    echo "üåê Checking network connectivity..."
    if ! curl -s --head --max-time 5 https://www.fema.gov >/dev/null; then
        echo "‚ùå Network check failed using curl. Unable to reach FEMA.gov."
        echo "üîå Please check your internet connection and try again."
        exit 1
    fi

    # Decide parallelism: (2d3)
    rand_byte=$(od -An -N1 -tu1 </dev/urandom)
    jobs=$(((rand_byte % 3 + 1) + ($(od -An -N1 -tu1 </dev/urandom) % 3 + 1)))
    IFS=, big_list="${needed_files[*]}"
    unset IFS
    echo "üìÇ Passed. Downloading files..."
    curl --parallel \
        "${BASE_URL}"\{"${big_list}"\} \
        "${BASE_URL}"\{"${big_list}"\}.sig \
        --parallel-max "${jobs}" \
        --fail # EMOTIONAL DAMAGE‚Ñ¢
else
    echo "üìÇ All files and signatures found locally ‚Äî skipping network check."
fi

# --- Persistent workspace keyring ---
LOCAL_GNUPGHOME="${SOURCE_ROOT}/.gnupg-local"
mkdir -p "$LOCAL_GNUPGHOME"
chmod 700 "$LOCAL_GNUPGHOME"
export GNUPGHOME="$LOCAL_GNUPGHOME"

KEYSERVERS=("hkps://keys.openpgp.org" "hkps://keyserver.ubuntu.com")

# printfüôπ
# DISHONOR!!!!! DISHONOR ON YOUR WHOLE FAMILY!!!
# DISHONOR ON YOU!!!one!!! DISHONOR ON YOUR COW!!!!!
rand_delay() {
    local ms=$(($(od -An -N1 -tu1 </dev/urandom) % 1000 + 1))
    sleep "0.$(printf "%03d" "$ms")"

}

bad_sigs=()
no_pubkey=()
no_pubkey_after_lookup=()

for f in "${filenames[@]}"; do
    sig="${f}.sig"

    # Try verification with default keyring
    if (GNUPGHOME='' gpgv "$sig" "$f" >/dev/null 2>&1); then
        continue
    fi

    # Try verification with local keyring
    if gpgv "$sig" "$f" >/dev/null 2>&1; then
        continue
    fi

    # If both fail, check why
    output=$(gpgv "$sig" "$f" 2>&1)
    if [[ $output == *"Can't check signature: No public key"* ]]; then
        no_pubkey+=("$f")

        # Extract email and keyid from signature
        email=$(gpg --list-packets "$sig" | awk -F'[<>]' '/user ID/ {print $2; exit}')
        keyid=$(gpg --list-packets "$sig" | awk '/keyid/ {print $2; exit}')

        # Try WKD first (local keyring only)
        if [[ -n $email ]]; then
            echo "Trying WKD for $email..."
            rand_delay
            gpg --auto-key-locate wkd --locate-key "$email" >/dev/null 2>&1
        fi

        # If WKD failed or no email, try keyservers (local keyring only)
        if ! gpg --list-keys "$keyid" >/dev/null 2>&1; then
            for ks in "${KEYSERVERS[@]}"; do
                echo "Fetching $keyid from $ks..."
                rand_delay
                gpg --keyserver "$ks" --recv-keys "$keyid" >/dev/null 2>&1 && break
            done
        fi

        # If key fetched, try WKD again using UID from local keyring
        if gpg --list-keys "$keyid" >/dev/null 2>&1; then
            if [[ -z $email ]]; then
                email=$(GNUPGHOME="$LOCAL_GNUPGHOME" gpg --list-keys --with-colons "$keyid" | awk -F: '/uid:/ {print $10; exit}')
            fi
            if [[ -n $email ]]; then
                echo "Verifying $email via WKD..."
                gpg --auto-key-locate wkd --locate-key "$email" >/dev/null 2>&1
            fi
        else
            no_pubkey_after_lookup+=("$f")
        fi

    else
        bad_sigs+=("$f")
    fi
done

# No entry to Sto-Vo-Kor for those who use printf!!!!!!!!
if ((${#bad_sigs[@]} > 0 || ${#no_pubkey_after_lookup[@]} > 0)); then
    echo "ERROR: Bad signatures or unresolved missing keys found ‚Äî terminating."
    echo "=== Bad Signatures (Group 1) ==="
    printf '%s\n' "${bad_sigs[@]:-(none)}"
    echo
    echo "=== Still No Public Key After WKD + Keyservers (Group 3) ==="
    printf '%s\n' "${no_pubkey_after_lookup[@]:-(none)}"
    exit 1
fi

extract_archive() {
    local filename="$1"
    local mime
    mime=$(file --mime-type -b "$filename")

    case "$mime" in
    application/x-gzip) tar -xvzf "$filename" ;;
    application/gzip) tar -xvzf "$filename" ;;
    application/x-bzip2) tar -xvjf "$filename" ;;
    application/x-xz) tar -xvJf "$filename" ;;
    application/zstd) tar --zstd -xvf "$filename" ;;
    application/x-tar) tar -xvf "$filename" ;;
    *)
        echo "‚ö†Ô∏è Unknown archive type for $filename ($mime), trying plain tar..."
        tar -xvf "$filename"
        ;;
    esac

}

loop=0
for f in "${filenames[@]}"; do
    extract_archive "${f[loop]}" & # YOLO!
    ((loop++))
done
wait