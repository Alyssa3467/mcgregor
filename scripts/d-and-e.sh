#!/usr/bin/env bash
# (Mostly) Generated by Microsoft Copilot with a bit of coaxing
# (and quite a bit of annoyance)

# Detect if this file is being sourced or run directly
# BASH_SOURCE[0] is the current file, $0 is the script name
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    # This file is being executed directly
    echo "‚ö†Ô∏è This script should be sourced, not executed."
    exit 1
fi

# --- Wrapper functions for consistent defaults ---
curl_wrapper() {
    curl --config "${SOURCE_ROOT}/.curlrc" "$@"
}

# --- Project-local curl defaults ---
CURLRC="${SOURCE_ROOT}/.curlrc"
if [[ ! -f "$CURLRC" ]]; then
    cat >"$CURLRC" <<'EOF'
retry = 5
retry-delay = 2
retry-all-errors
max-time = 30
fail
silent
show-error
EOF
fi

gpgv_wrapper() {
    gpgv --weak-digest reject "$@"
}

gpg_wrapper() {
    with_keyring_lock gpg "$@"
}

cleanup() {
    rm -f /tmp/lotto_org.* /tmp/lotto_ur.* "${LOCKFILE:-}"
}
trap 'echo "Interrupted (INT), cleaning up‚Ä¶" >&2; cleanup; exit 130' INT
trap 'echo "Terminated (TERM), cleaning up‚Ä¶" >&2; cleanup; exit 143' TERM
trap cleanup EXIT

# This will be moved to lotto.sh at some point.
lotto() {
    org_temp=$(mktemp /tmp/lotto_org.XXXXXX)
    ur_temp=$(mktemp /tmp/lotto_ur.XXXXXX)
    {
        # Get 5 numbers from random.org (1‚Äì70), sorted
        nums=$(curl_wrapper -s "https://www.random.org/integers/?num=5&min=1&max=70&col=1&base=10&format=plain&rnd=new")
        readarray -t arr <<<"$nums"
        sorted_org=$(for i in "${arr[@]}"; do echo "$i"; done | (LC_ALL=vn_VN sort -n))

        # Get 1 number from random.org (1‚Äì25)
        sixth=$(curl_wrapper -s "https://www.random.org/integers/?num=1&min=1&max=25&col=1&base=10&format=plain&rnd=new")
        echo "$sorted_org"$'\n'"$sixth" >"${org_temp}"
    } &

    {
        # Get 5 numbers from /dev/urandom (1‚Äì70), sorted
        ur_arr=()
        while [ "${#ur_arr[@]}" -lt 5 ]; do
            num=$((($(od -An -N2 -tu2 </dev/urandom) % 70) + 1))
            ur_arr+=("$num")
        done
        sorted_ur=$(for i in "${ur_arr[@]}"; do echo "$i"; done | (LC_ALL=vn_VN sort -n))

        # Get 1 number from /dev/urandom (1‚Äì25)
        sixth_ur=$((($(od -An -N2 -tu2 </dev/urandom) % 25) + 1))
        echo "$sorted_ur"$'\n'"$sixth_ur" >"${ur_temp}"
    } &

    wait

    mapfile -t org_nums <"$org_temp"
    mapfile -t ur_nums <"$ur_temp"
    rm -f "$org_temp" "$ur_temp"

    if [ "${org_nums[*]}" = "${ur_nums[*]}" ]; then
        return 0
    else
        return 1
    fi
}

mkdir -p "${SOURCE_ROOT}" && cd "${SOURCE_ROOT}" || exit

export BASE_URL="https://ftpmirror.gnu.org/"
# --- Files to fetch (relative to mirror root) ---
FILES=(
    "binutils/binutils-2.45.tar.bz2"
    "gcc/gcc-15.2.0/gcc-15.2.0.tar.gz"
    "mpfr/mpfr-4.2.2.tar.bz2"
    "gmp/gmp-6.3.0.tar.bz2"
    "mpc/mpc-1.3.1.tar.gz"
    "glibc/glibc-2.42.tar.bz2"
)

# --- Check if all files and signatures exist locally ---
needed_files=()
filenames=()
file_count=0
all_present=true

for f in "${FILES[@]}"; do
    filenames+=("$(basename "$f")")
    if [[ ! -f "${filenames[file_count]}" || ! -f "${filenames[file_count]}.sig" ]]; then
        all_present=false
        needed_files+=("${f}")
    fi
    ((++file_count))
done

# --- Conditional network connectivity test ---
if [[ "$all_present" == false ]]; then
    echo "üåê Checking network connectivity..."
    if ! curl_wrapper -s --head --max-time 5 http://www.msftconnecttest.com/connecttest.txt >/dev/null; then
        echo "‚ùå Network check failed using curl. Unable to reach connection test site."
        echo "‚òéÔ∏è Please check your internet connection and try again."
        # If you'd like to make a call, hang up and try again. If you need help, dial the operator
        exit 1
    fi

    echo "üìû Passed. Downloading $((${#needed_files[@]} * 2)) files..."
    # Decide parallelism: (2d3)
    rand_byte=$(od -An -N1 -tu1 </dev/urandom)
    jobs=$(((rand_byte % 3 + 1) + ($(od -An -N1 -tu1 </dev/urandom) % 3 + 1)))
    IFS=, big_list="${needed_files[*]}"
    unset IFS
    curl --parallel \
        --parallel-max "${jobs}" \
        --remote-name-all \
        "${BASE_URL}"\{"${big_list}"\} \
        "${BASE_URL}"\{"${big_list}"\}.sig \
        --location \
        --write-out '%{url_effective} %{http_code}\n' -s -o /dev/null \
        --fail # EMOTIONAL DAMAGE‚Ñ¢
else
    echo "üìÇ All files and signatures found locally ‚Äî skipping network check."
fi
wait
# --- Persistent workspace keyring ---
LOCAL_GNUPGHOME="${SOURCE_ROOT}/.gnupg-local"
mkdir -p "$LOCAL_GNUPGHOME"
chmod 700 "$LOCAL_GNUPGHOME"
export GNUPGHOME="$LOCAL_GNUPGHOME"

KEYSERVERS=("hkps://keys.openpgp.org" "hkps://keyserver.ubuntu.com")

# # printfüôπ
# # DISHONOR!!!!! DISHONOR ON YOUR WHOLE FAMILY!!!
# # DISHONOR ON YOU!!!one!!! DISHONOR ON YOUR COW!!!!!
# rand_delay() {
#     local ms=$(($(od -An -N1 -tu1 </dev/urandom) % 1000 + 1))
#     sleep "0.$(printf "%03d" "$ms")"
# }

# Honor restored! You are reinstated, provisionally
rand_delay() {
    tmp=$(($(od -An -N4 -tu4 </dev/urandom) % 1000000))
    if [ "$tmp" -eq 42 ]; then
        if lotto; then
            sleep 7
        else
            sleep 0
        fi
    else
        tmp=$(("${tmp}" % 2))
        time=0
        if [ "$tmp" -eq 1 ]; then
            ms=$(($(od -An -N1 -tu1 </dev/urandom) % 1000 + 1))
            case "$ms" in
            1000) time=1 ;;
            [0-9]) time="0.00$ms" ;;
            [1-9][0-9]) time="0.0$ms" ;;
            *) time="0.$ms" ;;
            esac
        else
            d1=$(($(od -An -N1 -tu1 </dev/urandom) % 10))
            d2=$(($(od -An -N1 -tu1 </dev/urandom) % 10))
            d3=$(($(od -An -N1 -tu1 </dev/urandom) % 10))
            time="0.$d1$d2$d3"
            if ((time == 0)); then time=1; fi
        fi
        sleep "${time}"
    fi
}

bad_sigs=()
no_pubkey=()

LOCKFILE="${SOURCE_ROOT}/.gpg-import.lock"

with_keyring_lock() {
    # $@ is the command to run under lock
    {
        flock 200
        "$@"
    } 200>"$LOCKFILE"
}

verify_sig() {
    local f="$1"
    local sig="${f}.sig"

    # Try verification with default keyring as well as local keyring
    if (GNUPGHOME='' gpgv_wrapper --weak-digest reject "$sig" "$f" >/dev/null 2>&1) || gpgv_wrapper "$sig" "$f" >/dev/null 2>&1; then
        return
    fi

    # If both fail, check why
    output=$(gpgv_wrapper --weak-digest reject "$sig" "$f" 2>&1)
    if [[ $output == *"Can't check signature: No public key"* ]]; then
        echo "Can't check signature for $f: No public key"

        # Extract email and keyid from signature
        email=$(gpg --list-packets "$sig" | awk -F'[<>]' '/user ID/ {print $2; exit}')
        keyid=$(gpg --list-packets "$sig" | awk '/keyid/ {print $2; exit}')

        # Try WKD first (local keyring only)
        if [[ -n $email ]]; then
            echo "Trying WKD for $email..."
            rand_delay
            gpg_wrapper --auto-key-locate wkd --locate-key "$email" >/dev/null 2>&1
        fi

        # If WKD failed or no email, try keyservers (local keyring only)
        if ! gpg --list-keys "$keyid" >/dev/null 2>&1; then
            for ks in "${KEYSERVERS[@]}"; do
                echo "Fetching $keyid from $ks..."
                rand_delay
                gpg_wrapper --keyserver "$ks" --recv-keys "$keyid" >/dev/null 2>&1 && break
            done
        fi

        # If key fetched, try WKD again using UID from local keyring
        if gpg --list-keys "$keyid" >/dev/null 2>&1; then
            if [[ -z $email ]]; then
                email=$(GNUPGHOME="$LOCAL_GNUPGHOME" gpg_wrapper --list-keys --with-colons "$keyid" | awk -F: '/uid:/ {print $10; exit}')
            fi
            if [[ -n $email ]]; then
                echo "Verifying $email via WKD..."
                gpg_wrapper --auto-key-locate wkd --locate-key "$email" >/dev/null 2>&1
            fi
        else
            no_pubkey+=("$f")
        fi

    else
        bad_sigs+=("$f")
    fi
}

for f in "${filenames[@]}"; do
    verify_sig "$f" &
done
wait

# No entry to Sto-Vo-Kor for those who use printf!!!!!!!! (previous revision used it)
if ((${#bad_sigs[@]} > 0 || ${#no_pubkey[@]} > 0)); then
    echo "ERROR: Bad signatures or unresolved missing keys found ‚Äî terminating."
    echo "=== Bad Signatures ==="
    if ((${#bad_sigs[@]})); then
        for f in "${bad_sigs[@]}"; do
            echo "$f"
        done
    else
        echo "(none)"
    fi
    echo "=== No Public Key ==="
    if ((${#no_pubkey[@]})); then
        for f in "${no_pubkey[@]}"; do
            echo "$f"
        done
    else
        echo "(none)"
    fi
    exit 1
fi

extract_archive() {
    local tarflags=()
    local filename="$1"
    local mime
    mime=$(file --mime-type -b "$filename")

    base="${filename%.*}" # strip one extension
    base="${base%.*}"     # strip two (e.g. .tar.gz)
    if [ -f "$base/.marker" ]; then
        echo "‚úÖ Extraction marker found, skipping"
        return 0
    fi

    case "$mime" in
    application/x-gzip) tarflags=(-xvzf) ;;
    application/gzip) tarflags=(-xvzf) ;;
    application/x-bzip2) tarflags=(-xvjf) ;;
    application/x-xz) tarflags=(-xvJf) ;;
    application/zstd) tarflags=(--zstd -xvf) ;;
    application/x-tar) tarflags=(-xvf) ;;
    *)
        echo "‚ö†Ô∏è Unknown archive type for $filename ($mime), trying plain tar..."
        tarflags=(-xvf)
        ;;
    esac

    if tar "${tarflags[@]}" "$filename"; then
        touch "$base/.marker"
    fi
}

wait
for f in "${filenames[@]}"; do
    extract_archive "${f}" & # YOLO!
done
wait
